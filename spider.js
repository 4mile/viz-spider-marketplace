!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.spider=n():e.spider=n()}(window,function(){return function(e){var n={};function t(a){if(n[a])return n[a].exports;var l=n[a]={i:a,l:!1,exports:{}};return e[a].call(l.exports,l,l.exports,t),l.l=!0,l.exports}return t.m=e,t.c=n,t.d=function(e,n,a){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:a})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(t.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var l in e)t.d(a,l,function(n){return e[n]}.bind(null,l));return a},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="./src/spider.js")}({"./src/spider.js":
/*!***********************!*\
  !*** ./src/spider.js ***!
  \***********************/
/*! no static exports found */function(module,exports){eval('/**\n * Welcome to the Looker Visualization Builder! Please refer to the following resources \n * to help you write your visualization:\n *  - API Documentation - https://github.com/looker/custom_visualizations_v2/blob/master/docs/api_reference.md\n *  - Example Visualizations - https://github.com/looker/custom_visualizations_v2/tree/master/src/examples\n **/\nfunction RadarChart(id, data, options, moreData, colorSeries, originalData, axes, doneRendering) {\n  var cfg = {\n    w: 600,\n    //Width of the circle\n    h: 600,\n    //Height of the circle\n    margin: {\n      top: 20,\n      right: 20,\n      bottom: 20,\n      left: 20\n    },\n    //The margins of the SVG\n    levels: 3,\n    //How many levels or inner circles should there be drawn\n    maxValue: 0,\n    //What is the value that the biggest circle will represent\n    labelFactor: 1.325,\n    //How much farther than the radius of the outer circle should the labels be placed\n    wrapWidth: 60,\n    //The number of pixels after which a label needs to be given a new line\n    opacityArea: 0.15,\n    //The opacity of the area of the blob\n    dotRadius: 5,\n    //The size of the colored circles of each blog\n    opacityCircles: 0.15,\n    //The opacity of the circles of each blob\n    strokeWidth: 2,\n    //The width of the stroke around each blob\n    roundStrokes: true,\n    //If true the area and stroke will follow a round path (cardinal-closed)\n    color: d3.scale.category10(),\n    //Color function\n    legendSide: \'left\',\n    //Side legend appears\n    glow: 2,\n    //value controlling glow strength\n    negatives: true,\n    //allow negatives to be plotted?\n    axisColor: "#CDCDCD",\n    //color of the axis grid lines\n    backgroundColor: "#CDCDCD",\n    //background color of chart\n    negativeR: .81,\n    //scalar dictating negative axis length\n    independent: true,\n    //decouple axes?\n    axisFont: 2,\n    //font of the axis labels\n    scaleFont: 1,\n    //font of the scale\n    legendPad: 10,\n    //separation between legend items\n    legendFont: .8,\n    //font of legend items\n    domainMax: null,\n    labelScale: true,\n    labelFine: 1.2\n  }; //Put all of the options into a variable called cfg\n\n  if (\'undefined\' !== typeof options) {\n    for (var i in options) {\n      if (\'undefined\' !== typeof options[i]) {\n        cfg[i] = options[i];\n      }\n    } //for i\n\n  } //if\n  //If the supplied maxValue is smaller than the actual one, replace by the max in the data\n\n\n  var maxValue = cfg.domainMax ? Math.max(cfg.domainMax, d3.max(data, function (i) {\n    return d3.max(i.map(function (o) {\n      return o.value;\n    }));\n  })) : d3.max(data, function (i) {\n    return d3.max(i.map(function (o) {\n      return o.value;\n    }));\n  });\n  var deterSide = Math.min(cfg.w, cfg.h);\n  var allAxis = data[0].map(function (i, j) {\n    return i.axis;\n  }),\n      //Names of each axis\n  total = allAxis.length,\n      //The number of different axes\n  radius = Math.min(deterSide * .35, cfg.legendSide === \'center\' ? deterSide * .3 : deterSide * .45),\n      //Radius of the outermost circle\n  Format = d3.format(",.0f"),\n      //Label formatting\n  angleSlice = Math.PI * 2 / total; //The width in radians of each "slice"\n  //Scale for the radius\n\n  if (cfg.independent) {\n    axesMax = [];\n    data.forEach(function (d) {\n      d.forEach(function (i) {\n        if (!(i.axis in axesMax)) {\n          axesMax[i.axis] = Math.abs(i.value);\n        } else if (Math.abs(i.value) > axesMax[i.axis]) {\n          axesMax[i.axis] = Math.abs(i.value);\n        }\n      });\n    });\n    rScale = [];\n    allAxis.map(function (d) {\n      rScale.push(d3.scale.linear().range([0, radius]).domain([0, axesMax[d]]));\n    });\n    maxValue = [];\n    allAxis.map(function (d) {\n      maxValue.push(axesMax[d]);\n    });\n  } else {\n    var maxValues = cfg.domainMax ? Math.max(cfg.domainMax, d3.max(data, function (i) {\n      return d3.max(i.map(function (o) {\n        return o.value;\n      }));\n    })) : d3.max(data, function (i) {\n      return d3.max(i.map(function (o) {\n        return o.value;\n      }));\n    });\n    rScale = [];\n    allAxis.map(function (d) {\n      rScale.push(d3.scale.linear().range([0, radius]).domain([0, maxValue]));\n    });\n    maxValue = [];\n    allAxis.map(function (d) {\n      maxValue.push(maxValues);\n    });\n  } /////////////////////////////////////////////////////////\n  //////////// Create the container SVG and g /////////////\n  /////////////////////////////////////////////////////////\n  //Remove whatever chart with the same id/class was present before\n\n\n  d3.select(id).select("svg").remove(); //Initiate the radar chart SVG\n\n  var svg = d3.select(id).append("svg").attr("font-family", `"Open Sans", "Noto Sans JP", "Noto Sans CJK KR", sans-serif`).attr("width", cfg.w).attr("height", cfg.h + cfg.margin.bottom).attr("class", "radar" + id); //Append a g element\t\n\n  var moveH = cfg.legendSide === \'center\' ? cfg.h / 2 - cfg.margin.top : cfg.h / 2 + cfg.margin.top;\n  var g = svg.append("g").attr("transform", "translate(" + cfg.w / 2 + "," + moveH + ")"); /////////////////////////////////////////////////////////\n  ////////// Glow filter for some extra pizzazz ///////////\n  /////////////////////////////////////////////////////////\n  //Filter for the outside glow\n\n  var filter = g.append(\'defs\').append(\'filter\').attr(\'id\', \'glow\'),\n      feGaussianBlur = filter.append(\'feGaussianBlur\').attr(\'stdDeviation\', `${cfg.glow}`).attr(\'result\', \'coloredBlur\'),\n      feMerge = filter.append(\'feMerge\'),\n      feMergeNode_1 = feMerge.append(\'feMergeNode\').attr(\'in\', \'coloredBlur\'),\n      feMergeNode_2 = feMerge.append(\'feMergeNode\').attr(\'in\', \'SourceGraphic\'); /////////////////////////////////////////////////////////\n  /////////////// Draw the Circular grid //////////////////\n  /////////////////////////////////////////////////////////\n  //Wrapper for the grid & axes\n\n  var axisGrid = g.append("g").attr("class", "axisWrapper"); //console.log(d3.range(1,(cfg.levels+1)).reverse());\n  //Text indicating at what % each level is\n\n  if (cfg.independent) {\n    allAxis.forEach(function (d, i) {\n      //console.log(d, maxValue[i]);\n      d3.range(1, cfg.levels + 1).reverse().forEach(function (dd, ii) {\n        axisGrid.append("text").attr("class", "axisLabel").attr("x", dd / cfg.levels * radius * Math.cos(angleSlice * i - Math.PI / 2)).attr("y", dd / cfg.levels * radius * Math.sin(angleSlice * i - Math.PI / 2)).attr("dy", "0.35em").attr("dy", "0.35em").style("font-size", `${cfg.labelScale ? cfg.scaleFont : 0}px`).style("font-weight", "900").style("z-index", 10).attr("fill", cfg.axisColor).text(Format(maxValue[i] * dd / cfg.levels));\n      });\n    });\n  } else {\n    axisGrid.selectAll(".axisLabel").data(d3.range(1, cfg.levels + 1).reverse()).enter().append("text").attr("class", "axisLabel").attr("x", 4).attr("y", function (d) {\n      return -d * radius / cfg.levels;\n    }).attr("dy", "0.4em").style("font-size", `${cfg.labelScale ? cfg.scaleFont : 0}px`).style("font-weight", "900").style("z-index", 10).attr("fill", cfg.axisColor).text(function (d) {\n      return Format(maxValue[0] * d / cfg.levels);\n    });\n  } /////////////////////////////////////////////////////////\n  //////////////////// Draw the axes //////////////////////\n  /////////////////////////////////////////////////////////\n\n\n  var negativeR = 1; //console.log(total);\n\n  if (cfg.roundStrokes) {\n    negativeR = 1;\n  } else if (total == 3) {\n    negativeR = .5;\n  } else if (total == 5) {\n    negativeR = .81;\n  } else if (total == 7) {\n    negativeR = .9;\n  } else if (total == 9) {\n    negativeR = .94;\n  } else if (total == 11) {\n    negativeR = .96;\n  } //console.log(negativeR);\n  //Create the straight lines radiating outward from the center\n\n\n  var axis = axisGrid.selectAll(".axis").data(allAxis).enter().append("g").attr("class", "axis"); //Append the lines\n\n  axis.append("line").attr("x1", function (d, i) {\n    if (cfg.roundStrokes) {\n      if (cfg.negatives) {\n        return rScale[i](maxValue[i] * -1) * Math.cos(angleSlice * i - Math.PI / 2);\n      } else {\n        return 0;\n      }\n    } else {\n      if (cfg.negatives) {\n        return rScale[i](maxValue[i] * -negativeR) * Math.cos(angleSlice * i - Math.PI / 2);\n      } else {\n        return 0;\n      }\n    }\n  }).attr("y1", function (d, i) {\n    if (cfg.roundStrokes) {\n      if (cfg.negatives) {\n        return rScale[i](maxValue[i] * -1) * Math.sin(angleSlice * i - Math.PI / 2);\n      } else {\n        return 0;\n      }\n    } else {\n      if (cfg.negatives) {\n        return rScale[i](maxValue[i] * -negativeR) * Math.sin(angleSlice * i - Math.PI / 2);\n      } else {\n        return 0;\n      }\n    }\n  }).attr("x2", function (d, i) {\n    return rScale[i](maxValue[i] * 1.0) * Math.cos(angleSlice * i - Math.PI / 2);\n  }).attr("y2", function (d, i) {\n    return rScale[i](maxValue[i] * 1.0) * Math.sin(angleSlice * i - Math.PI / 2);\n  }).attr("class", "line").style("stroke", function (d, i) {\n    return cfg.axisColor;\n  }).style("stroke-width", "2px"); //Append the labels at each axis\n\n  axis.append("text").attr("class", "legend").style("font-size", `${cfg.axisFont}px`).style("font-weight", "549").attr("text-anchor", "middle").style(\'fill\', \'rgb(102, 102, 102)\').attr("dy", "1em").attr("x", function (d, i) {\n    return rScale[i](maxValue[i] * cfg.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);\n  }).attr("y", function (d, i) {\n    return rScale[i](maxValue[i] * cfg.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2) - cfg.labelFine;\n  }).text(function (d) {\n    return d;\n  }).call(wrap, cfg.wrapWidth); //Draw the background circles\n\n  if (cfg.roundStrokes) {\n    axisGrid.selectAll(".levels").data(d3.range(1, cfg.levels + 1).reverse()).enter().append("circle").attr("class", "gridCircle").attr("r", function (d, i) {\n      return radius / cfg.levels * d;\n    }).style("fill", function (d, i) {\n      return cfg.backgroundColor;\n    }).style("stroke", function (d, i) {\n      return cfg.axisColor;\n    }).style("fill-opacity", cfg.opacityCircles).style("filter", "url(#glow)");\n  } else {\n    if (cfg.independent) {\n      levels = [];\n      axisGrid.selectAll(".axisLabel").forEach(function (d) {\n        s = d.length;\n        var n = s / total;\n        d.slice(0, n).forEach(function (d) {\n          set = [];\n          r = parseInt(d.getAttribute("y"));\n          axis[0].forEach(function (d, i) {\n            tempx = r * Math.cos(angleSlice * i - Math.PI * 3 / 2);\n            tempy = r * Math.sin(angleSlice * i - Math.PI * 3 / 2);\n            set.push({\n              x: tempx,\n              y: tempy\n            });\n          });\n          levels.push(set);\n        });\n      }); // console.log(levels);\n\n      levels.forEach(function (d) {\n        //console.log(d);\n        axisGrid.selectAll(".levels").data([d]).enter().append("polygon").attr("points", function (d) {\n          return d.map(function (d) {\n            return [d.x, d.y].join(",");\n          }).join(" ");\n        }).attr("class", "gridCircle").style("fill", function (d, i) {\n          return cfg.backgroundColor;\n        }).style("stroke", function (d, i) {\n          return cfg.axisColor;\n        }).style("fill-opacity", cfg.opacityCircles).style("filter", "url(#glow)");\n      });\n    } else {\n      levels = [];\n      axisGrid.selectAll(".axisLabel").forEach(function (d) {\n        s = d.length;\n        d.forEach(function (d) {\n          set = [];\n          r = parseInt(d.getAttribute("y"));\n          axis[0].forEach(function (d, i) {\n            tempx = r * Math.cos(angleSlice * i - Math.PI * 3 / 2);\n            tempy = r * Math.sin(angleSlice * i - Math.PI * 3 / 2);\n            set.push({\n              x: tempx,\n              y: tempy\n            });\n          });\n          levels.push(set);\n        });\n      }); // console.log(levels);\n\n      levels.forEach(function (d) {\n        //console.log(d);\n        axisGrid.selectAll(".levels").data([d]).enter().append("polygon").attr("points", function (d) {\n          return d.map(function (d) {\n            return [d.x, d.y].join(",");\n          }).join(" ");\n        }).attr("class", "gridCircle").style("fill", function (d, i) {\n          return cfg.backgroundColor;\n        }).style("stroke", function (d, i) {\n          return cfg.axisColor;\n        }).style("fill-opacity", cfg.opacityCircles).style("filter", "url(#glow)");\n      });\n    }\n  }\n\n  ; /////////////////////////////////////////////////////////\n  ///////////// Draw the radar chart blobs ////////////////\n  /////////////////////////////////////////////////////////\n  //The radial line function\n\n  var radarLine = d3.svg.line.radial().interpolate("linear-closed").radius(function (d, i) {\n    return rScale[i](cfg.negatives ? d.value < 0 ? d.value * .8 : d.value : d.value < 0 ? 0 : d.value);\n  }).angle(function (d, i) {\n    return i * angleSlice;\n  });\n\n  if (cfg.roundStrokes) {\n    radarLine.interpolate("cardinal-closed");\n  } //Create a wrapper for the blobs\t\n\n\n  var blobWrapper = g.selectAll(".radarWrapper").data(data).enter().append("g").attr("class", "radarWrapper").attr("id", function (d, i) {\n    return "v" + moreData[i].label.replace(/[^A-Z0-9]+/ig, "");\n  }); //Append the backgrounds\t\n\n  blobWrapper.append("path").attr("class", "radarArea").attr("id", function (d, i) {\n    return "v" + moreData[i].label.replace(/[^A-Z0-9]+/ig, "");\n  }).attr("d", function (d, i) {\n    return radarLine(d);\n  }).style("fill", function (d, i) {\n    return cfg.color(i);\n  }).style("fill-opacity", cfg.opacityArea).on(\'mouseover\', function (d, i) {\n    //Dim all blobs\n    d3.selectAll(".radarArea").transition().duration(200).style("fill-opacity", 0.1); //Bring back the hovered over blob\n\n    d3.select(this).transition().duration(200).style("fill-opacity", 0.7);\n  }).on(\'mouseout\', function () {\n    //Bring back all blobs\n    d3.selectAll(".radarArea").transition().duration(200).style("fill-opacity", cfg.opacityArea);\n  }); //Create the outlines\t\n\n  blobWrapper.append("path").attr("class", "radarStroke").attr("d", function (d, i) {\n    return radarLine(d);\n  }).style("stroke-width", cfg.strokeWidth + "px").style("stroke", function (d, i) {\n    return cfg.color(i);\n  }).style("fill", "none").style("filter", "url(#glow)"); //Append the circles\n\n  blobWrapper.selectAll(".radarCircle").data(function (d, i) {\n    return d;\n  }).enter().append("circle").attr("class", "radarCircle").attr("r", cfg.dotRadius).attr("cx", function (d, i) {\n    return rScale[i](cfg.negatives ? d.value < 0 ? d.value * cfg.negativeR : d.value : d.value < 0 ? 0 : d.value) * Math.cos(angleSlice * i - Math.PI / 2);\n  }).attr("cy", function (d, i) {\n    return rScale[i](cfg.negatives ? d.value < 0 ? d.value * cfg.negativeR : d.value : d.value < 0 ? 0 : d.value) * Math.sin(angleSlice * i - Math.PI / 2);\n  }).style("fill", function (d, i, j) {\n    return cfg.color(j);\n  }).style("fill-opacity", 1); /////////////////////////////////////////////////////////\n  //////// Append invisible circles for tooltip ///////////\n  /////////////////////////////////////////////////////////\n  //Wrapper for the invisible circles on top\n\n  var blobCircleWrapper = g.selectAll(".radarCircleWrapper").data(data).enter().append("g").attr("class", "radarCircleWrapper").attr("child_id", function (d, i) {\n    return "v" + moreData[i].label.replace(/[^A-Z0-9]+/ig, "");\n  }); //Append a set of invisible circles on top for the mouseover pop-up\n\n  blobCircleWrapper.selectAll(".radarInvisibleCircle").data(function (d, i) {\n    return d;\n  }).enter().append("circle").attr("class", "radarInvisibleCircle").attr("series_id", function (d, i) {\n    return this.parentNode.getAttribute("child_id");\n  }).attr("r", cfg.dotRadius * 3).attr("cx", function (d, i) {\n    return rScale[i](cfg.negatives ? d.value < 0 ? d.value * cfg.negativeR : d.value : d.value < 0 ? 0 : d.value) * Math.cos(angleSlice * i - Math.PI / 2);\n  }).attr("cy", function (d, i) {\n    return rScale[i](cfg.negatives ? d.value < 0 ? d.value * cfg.negativeR : d.value : d.value < 0 ? 0 : d.value) * Math.sin(angleSlice * i - Math.PI / 2);\n  }).style("fill", "none").style("pointer-events", "all").on("mouseover", function (d, i) {\n    newX = parseFloat(d3.select(this).attr(\'cx\')) - 10;\n    newY = parseFloat(d3.select(this).attr(\'cy\')) - 10;\n    d3.selectAll(".radarArea").transition().duration(200).style("fill-opacity", 0.1); //Bring back the hovered over blob\n\n    d3.select(".radarArea#" + this.parentNode.getAttribute("child_id")).transition().duration(200).style("fill-opacity", 0.7);\n    var render = {\n      value: d.rendered\n    };\n    tooltip.attr(\'x\', newX).attr(\'y\', newY).text(LookerCharts.Utils.textForCell(render)).transition().duration(200).style("pointer-events", "none").style(\'opacity\', 1);\n  }).on("click", function (d, i) {\n    LookerCharts.Utils.openDrillMenu({\n      links: d.links,\n      event: event\n    });\n  }).on("mouseout", function () {\n    tooltip.transition().duration(200).style("opacity", 0);\n    d3.selectAll(".radarArea").transition().duration(200).style("fill-opacity", cfg.opacityArea);\n  }); //Set up the small tooltip for when you hover over a circle\n\n  var tooltip = g.append("text").attr("class", "tooltip").style("opacity", 0); /////////////////////////////////////////////////////////\n  ///////////// \t\t\t\tLegend-airy\t\t  \t ////////////////\n  /////////////////////////////////////////////////////////\n\n  var style = document.createElement(\'style\');\n  style.type = \'text/css\';\n  style.innerHTML = \'g.radarWrapper.hidden { opacity: 0.0; } .legendCells .hidden { opacity: 0.2;text-align:center }\';\n  var ordinal = d3.scale.ordinal().domain(moreData.map(d => d.label)).range(moreData.map((d, i) => cfg.color(i)));\n  var svg = d3.select("svg");\n\n  if (cfg.legendSide === \'left\') {\n    legx = 20;\n    legy = 10;\n    leg_orient = \'vertical\';\n    leg_pad = cfg.legendPad + 0;\n  } else if (cfg.legendSide === \'right\') {\n    legx = cfg.w * 1.25;\n    legy = 20;\n    leg_orient = \'vertical\';\n    leg_pad = cfg.legendPad + 0;\n  } else if (cfg.legendSide === \'center\') {\n    legy = window.innerHeight - 60;\n    leg_orient = \'horizontal\';\n    leg_pad = cfg.legendPad + 50;\n  } else if (cfg.legendSide === \'none\') {\n    legx = -100;\n    legy = -150;\n    leg_orient = \'vertical\';\n    leg_pad = cfg.legendPad + 70;\n  }\n\n  svg.append("g").attr("class", "legendOrdinal").style("font-size", `${cfg.legendFont}px`).style("fill", \'rgb(102, 102, 102)\');\n  var legendOrdinal = d3.legend.color().shape("path", d3.svg.symbol().type("circle").size(120)()).shapePadding(leg_pad).scale(ordinal).orient(leg_orient).on(\'cellclick\', function (d) {\n    var d = d.replace(/[^A-Z0-9]+/ig, "");\n    toggleDataPoints(d);\n    const legendCell = d3.select(this);\n    legendCell.classed(\'hidden\', !legendCell.classed(\'hidden\')); // toggle opacity of legend item\n\n    series_sel = d3.select(`#v${d}`)[0][0].classList.contains(\'hidden\');\n\n    if (series_sel) {\n      d3.select(`#v${d}`).style("opacity", "0").style("pointer-events", "none");\n      d3.selectAll(`[child_id=v${d}]`).style("pointer-events", "none");\n      d3.selectAll(`[series_id=v${d}]`).style("pointer-events", "none");\n    } else {\n      d3.select(`#v${d}`).style("opacity", "1").style("pointer-events", null);\n      d3.selectAll(`[child_id=v${d}]`).style("pointer-events", "all");\n      d3.selectAll(`[series_id=v${d}]`).style("pointer-events", "all");\n    }\n\n    legend_tru = legendCell[0][0].classList.contains(\'hidden\');\n\n    if (legend_tru) {\n      d3.select(this).style("opacity", ".2");\n    } else {\n      d3.select(this).style("opacity", "1");\n    }\n  });\n  svg.select(".legendOrdinal").call(legendOrdinal); //console.log(d3.select(\'.legendCells\').node().getBBox().width);\n\n  if (cfg.legendSide == \'center\') {\n    wid = window.innerWidth / 2 - d3.select(\'.legendCells\').node().getBBox().width / 2 + cfg.margin.left;\n    d3.select(".legendOrdinal").attr("transform", function (d) {\n      return `translate(${wid},${legy})`;\n    });\n  } else if (cfg.legendSide == \'right\') {\n    wid = window.innerWidth - d3.select(\'.legendCells\').node().getBBox().width * 1.25;\n    d3.select(".legendOrdinal").attr("transform", function (d) {\n      return `translate(${wid},${legy})`;\n    });\n  } else {\n    d3.select(".legendOrdinal").attr("transform", function (d) {\n      return `translate(${legx},${legy})`;\n    });\n  } /////////////////////////////////////////////////////////\n  /////////////////// Helper Function /////////////////////\n  /////////////////////////////////////////////////////////\n  //Taken from http://bl.ocks.org/mbostock/7555321\n  //Wraps SVG text\t\n\n\n  function wrap(text, width) {\n    text.each(function () {\n      var text = d3.select(this),\n          words = text.text().split(/\\s+/).reverse(),\n          word,\n          line = [],\n          lineNumber = 0,\n          lineHeight = 1.4,\n          // ems\n      y = text.attr("y"),\n          x = text.attr("x"),\n          dy = parseFloat(text.attr("dy")),\n          tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");\n\n      while (word = words.pop()) {\n        line.push(word);\n        tspan.text(line.join(" "));\n\n        if (tspan.node().getComputedTextLength() > width) {\n          line.pop();\n          tspan.text(line.join(" "));\n          line = [word];\n          tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);\n        }\n      }\n    });\n  } //wrap\t\n\n\n  function toggleDataPoints(colorClass) {\n    d3.selectAll(`#v${colorClass}`).classed(\'hidden\', function () {\n      // toggle "hidden" class\n      return !d3.select(this).classed(\'hidden\');\n    });\n  }\n\n  doneRendering();\n} //RadarChart\n\n\nconst baseOptions = {\n  levels: {\n    type: "number",\n    label: "Levels",\n    default: 4,\n    section: "Plot"\n  },\n  label_factor: {\n    type: "number",\n    label: "Axis Label Padding",\n    default: 85,\n    section: "Plot - Advanced",\n    display: "range",\n    order: 4\n  },\n  label_fine: {\n    type: "number",\n    label: "Axis Label Positioning",\n    default: 6,\n    section: "Plot - Advanced",\n    display: "range",\n    order: 5\n  },\n  levels: {\n    type: "number",\n    label: "Plot Levels",\n    default: 3,\n    section: "Plot"\n  },\n  domain_max: {\n    type: "number",\n    label: "Axis Max Override",\n    section: "Plot"\n  },\n  rounded_strokes: {\n    type: "string",\n    label: "Rounded Strokes?",\n    display: "select",\n    values: [{\n      "true": true\n    }, {\n      "false": false\n    }],\n    default: true,\n    section: "Plot"\n  },\n  independent: {\n    type: "string",\n    label: "Normalize Axes?",\n    display: "select",\n    values: [{\n      "true": true\n    }, {\n      "false": false\n    }],\n    default: false,\n    section: "Plot"\n  },\n  labelScale: {\n    type: "string",\n    label: "Label Scale?",\n    display: "select",\n    values: [{\n      "true": true\n    }, {\n      "false": false\n    }],\n    default: true,\n    section: "Plot"\n  },\n  negatives: {\n    type: "string",\n    label: "Allow Negatives?",\n    display: "select",\n    values: [{\n      "true": true\n    }, {\n      "false": false\n    }],\n    default: false,\n    section: "Plot"\n  },\n  wrap_width: {\n    type: "number",\n    label: "Axis Label Wrapping",\n    default: 100,\n    section: "Plot - Advanced",\n    order: 6\n  },\n  opacity_area: {\n    type: "number",\n    label: "Area Darkness",\n    display: "range",\n    default: 15,\n    section: "Series",\n    order: 0\n  },\n  dot_radius: {\n    type: "number",\n    label: "Point Radius",\n    default: 30,\n    display: "range",\n    section: "Series",\n    order: 1\n  },\n  opacity_circles: {\n    type: "number",\n    label: "Background Darkness",\n    display: "range",\n    default: 15,\n    section: "Plot - Advanced",\n    order: 2\n  },\n  backgroundColor: {\n    type: `string`,\n    label: `Background Color`,\n    display: `color`,\n    section: "Plot - Advanced",\n    default: "#CDCDCD",\n    order: 1\n  },\n  axisColor: {\n    type: `string`,\n    label: `Axis Color`,\n    display: `color`,\n    section: "Plot - Advanced",\n    default: "#CDCDCD",\n    order: 0\n  },\n  stroke_width: {\n    type: "number",\n    label: "Stroke Width",\n    default: 15,\n    display: "range",\n    section: "Series",\n    order: 2\n  },\n  glow: {\n    type: "number",\n    label: "Glow Range",\n    default: 2,\n    display: "range",\n    section: "Plot - Advanced"\n  },\n  axis_label_font: {\n    type: "number",\n    label: "Axis Label Font Size (px)",\n    default: 12,\n    section: "Plot - Advanced"\n  },\n  axis_scale_font: {\n    type: "number",\n    label: "Scale Font Size (px)",\n    default: 12,\n    section: "Plot - Advanced"\n  },\n  legend_font: {\n    type: "number",\n    label: "Legend Font Size (px)",\n    default: 12,\n    section: "Plot - Advanced"\n  },\n  legend_padding: {\n    type: "number",\n    label: "Legend Item Padding",\n    default: 20,\n    display: "range",\n    section: "Plot - Advanced"\n  },\n  legend_side: {\n    type: "string",\n    label: "Legend",\n    display: "select",\n    values: [{\n      "none": "none"\n    }, {\n      "left": "left"\n    }, {\n      "right": "right"\n    }, {\n      "center": "center"\n    }],\n    default: "left",\n    section: "Plot"\n  }\n};\nlet baseConfig = {};\nconst visObject = {\n  /**\n   * Configuration options for your visualization. In Looker, these show up in the vis editor\n   * panel but here, you can just manually set your default values in the code.\n   **/\n\n  /**\n   * The create function gets called when the visualization is mounted but before any\n   * data is passed to it.\n   **/\n  create: function (element, config) {\n    element.innerHTML = `<div style=\'font-family: "Open Sans", "Noto Sans JP", "Noto Sans", "Noto Sans CJK KR", Helvetica, Arial, sans-serif;\'/>`;\n  },\n\n  /**\n   * UpdateAsync is the function that gets called (potentially) multiple times. It receives\n   * the data and should update the visualization with the new data.\n   **/\n  updateAsync: function (data, element, config, queryResponse, details, doneRendering) {\n    if (data.length < 1) {\n      this.addError({\n        title: "No results.",\n        message: ""\n      }); // Display no results message\n\n      d3.select(\'#vis\').text(\'No Results\');\n      doneRendering();\n      return;\n    } // set the dimensions and margins of the graph\n\n\n    const addLight = function (color, amount) {\n      let cc = parseInt(color, 16) + amount;\n      let c = cc > 255 ? 255 : cc;\n      c = c.toString(16).length > 1 ? c.toString(16) : `0${c.toString(16)}`;\n      return c;\n    };\n\n    const lighten = (color, amount) => {\n      color = color.indexOf("#") >= 0 ? color.substring(1, color.length) : color;\n      amount = parseInt(255 * amount / 100);\n      return color = `#${addLight(color.substring(0, 2), amount)}${addLight(color.substring(2, 4), amount)}${addLight(color.substring(4, 6), amount)}`;\n    };\n\n    var margin = {\n      top: 20,\n      right: 20,\n      bottom: 20,\n      left: 20\n    },\n        width = element.clientWidth,\n        height = element.clientHeight; //console.log(data);\n    // append the svg object to the body of the page\n    // append a \'group\' element to \'svg\'\n    // moves the \'group\' element to the top left margin\n\n    element.innerHTML = "";\n    var svg = d3.select("#vis").append("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    var series_default = ["#4A80BC", "#615894", "#F0C733", "#D13452", "#E48522", "#B977A9", "#7bc739", "#92b3d7", "#e38597"];\n\n    if (queryResponse[\'pivots\']) {\n      // grab the series labels\n      series = []; //console.log(queryResponse[\'fields\'][\'measure_like\'].length % 2);\n\n      if (!(queryResponse[\'fields\'][\'measure_like\'].length % 2) && config.negatives) {\n        //console.log("troof");\n        this.addError({\n          title: "Can\'t display negatives with symmetric axes.",\n          message: "Negatives can only be plotted on odd number of axes."\n        });\n        return;\n      }\n\n      if (queryResponse[\'fields\'][\'measure_like\'].length < 3) {\n        this.addError({\n          title: "Multiple measures only.",\n          message: "This chart requires at least 3 measures."\n        });\n        return;\n      }\n\n      if (queryResponse[\'fields\'][\'dimensions\'].length > 0) {\n        this.addError({\n          title: "Single dimension only.",\n          message: "This chart accepts only 1, pivoted or unpivoted dimension."\n        });\n        return;\n      }\n\n      queryResponse[\'pivots\'].forEach(function (d) {\n        series.push(d[\'key\']);\n      });\n      originalData = data; // format the data\n      // get measure-like field names and label\n\n      axes = [];\n      queryResponse[\'fields\'][\'measure_like\'].forEach(function (d) {\n        axes.push({\n          name: d[\'name\'],\n          label: d[\'label_short\']\n        });\n      });\n      formattedData = [];\n      moreData = [];\n      series.forEach(function (s, index) {\n        values = [];\n        axes.forEach(function (a) {\n          values.push({\n            axis: a[\'label\'],\n            name: a[\'name\'],\n            value: data[0][a[\'name\']][s][\'value\'],\n            rendered: data[0][a[\'name\']][s][\'rendered\'] ? data[0][a[\'name\']][s][\'rendered\'] : data[0][a[\'name\']][s][\'value\'],\n            links: data[0][a[\'name\']][s][\'links\']\n          });\n        });\n        set = [];\n        values.forEach(function (v) {\n          set.push(v);\n        });\n        moreData.push({\n          label: s,\n          data: set,\n          color: index < 9 ? series_default[index] : lighten("#D13452", index * 1.7)\n        });\n        formattedData.push(set);\n      });\n    } else {\n      series = [];\n\n      if (!(queryResponse[\'fields\'][\'measure_like\'].length % 2) && config.negatives) {\n        console.log("troof");\n        this.addError({\n          title: "Can\'t display negatives with symmetric axes.",\n          message: "Negatives can only be plotted on odd number of axes."\n        });\n        return;\n      }\n\n      if (queryResponse[\'fields\'][\'measure_like\'].length < 3) {\n        this.addError({\n          title: "Multiple measures only.",\n          message: "This chart requires at least 3 measures."\n        });\n        return;\n      }\n\n      if (queryResponse[\'fields\'][\'dimension_like\'].length > 1) {\n        this.addError({\n          title: "Single dimension only.",\n          message: "This chart accepts only 1, pivoted or unpivoted dimension."\n        });\n        return;\n      }\n\n      originalData = data; //console.log(queryResponse[\'fields\'][\'measure_like\']);\n\n      qrn = queryResponse["fields"]["dimensions"][0].name;\n      axes = [];\n      queryResponse[\'fields\'][\'measure_like\'].forEach(function (d) {\n        axes.push({\n          name: d[\'name\'],\n          label: d[\'label_short\'] ? d[\'label_short\'] : d[\'label\']\n        });\n      });\n      formattedData = [];\n      moreData = [];\n      data.forEach(function (d, index) {\n        values = [];\n        axes.forEach(function (a) {\n          values.push({\n            axis: a[\'label\'],\n            name: a[\'name\'],\n            value: d[a[\'name\']][\'value\'],\n            rendered: d[a[\'name\']][\'rendered\'] ? d[a[\'name\']][\'rendered\'] : d[a[\'name\']][\'value\'],\n            links: d[a[\'name\']][\'links\']\n          });\n        });\n        set = [];\n        values.forEach(function (v) {\n          set.push(v);\n        });\n        moreData.push({\n          label: String(d[qrn][\'value\']),\n          data: set,\n          color: index < 9 ? series_default[index] : lighten("#D13452", index * 1.7)\n        });\n        formattedData.push(set);\n      });\n      series = moreData.map(s => s.label);\n    } //console.log(formattedData);\n    //console.log(moreData);\n    //color: index < 9 ? series_default[index] : lighten("#D13452", index*1.7),\n\n\n    opt = Object.assign({}, baseOptions);\n    moreData.forEach(function (s, index) {\n      opt[`${s.label}_color`] = {\n        type: `string`,\n        label: `${s.label} - Color`,\n        display: `color`,\n        section: "Series",\n        default: `${s.color}` //default: baseConfig[`${s.label}_color`] ? baseConfig[`${s.label}_color`] : [series_default[index]],\n\n      };\n    });\n    this.trigger(\'registerOptions\', opt); //var color = d3.scale.ordinal().range(moreData.map((d,index) => config[`${d.label}_color`] ? config[`${d.label}_color`] : [series_default[index]]));\n\n    var color = d3.scale.ordinal().range(Object.keys(config).filter(function (key) {\n      return key.indexOf(\'_color\') !== -1;\n    }).map(function (d) {\n      return config[d];\n    }));\n    let radarChartOptions1 = {};\n\n    if (config.levels) {\n      radarChartOptions1 = {\n        w: width,\n        h: height,\n        margin: margin,\n        maxValue: 0.5,\n        levels: config.levels,\n        roundStrokes: config.rounded_strokes,\n        color: color,\n        axisFont: config.axis_label_font,\n        scaleFont: config.axis_scale_font,\n        labelFactor: config.label_factor * 1.5 / 100,\n        labelFine: config.label_fine * 1.2,\n        wrapWidth: config.wrap_width,\n        opacityArea: config.opacity_area / 100,\n        dotRadius: config.dot_radius / 5,\n        opacityCircles: config.opacity_circles / 200,\n        backgroundColor: config.backgroundColor,\n        axisColor: config.axis_color,\n        strokeWidth: config.stroke_width / 5,\n        legendSide: config.legend_side,\n        glow: config.glow / 20,\n        negatives: config.negatives,\n        axisColor: config.axisColor,\n        negativeR: config.negative_r,\n        independent: config.independent,\n        legendPad: config.legend_padding,\n        legendFont: config.legend_font,\n        domainMax: config.domain_max,\n        labelScale: config.labelScale\n      };\n      RadarChart("#vis", formattedData, radarChartOptions1, moreData, [], originalData, axes, doneRendering);\n    }\n  }\n};\nlooker.plugins.visualizations.add(visObject);\n\n//# sourceURL=webpack://%5Bname%5D/./src/spider.js?')}})});